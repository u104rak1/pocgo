# ドメインレイヤー

## 概要
ドメインレイヤーは、ドメインモデルの知識をコードとして表現したもので、ビジネスロジックの核心部分が配置されます。このレイヤーには以下のコンポーネントが含まれます:
- ドメインエンティティ
- ドメインサービス
- 永続化用のリポジトリインターフェイス

他のレイヤーはドメインレイヤーに依存可能ですが、ドメインレイヤーは他のレイヤーに依存してはいけません。使用可能なライブラリとしては以下があります。
- Goの標準ライブラリ
- Goの準標準ライブラリ
- pkgディレクトリに配置されたアプリケーション独自のユーティリティ関数

*注意
プレゼンテーションレイヤーやインフラストラクチャーレイヤーに強く関連する型や処理は、このレイヤーに含めません。
例: echo.Context 型、トランザクション、SQLエラーなど

## 集約
ドメイン内部のディレクトリを集約単位で区切ります。pocgoでは以下のリストのように集約単位で分けています。
- account
- authentication
- transaction
- user

集約の設計
- 集約の設計は、ビジネスルールや整合性に基づいて決定します。
- 場合によっては、RESTfulリソースに合わせて分けることも有効です（API設計とモデル設計の整合性を保ち、理解を容易にするため）。

*注意
RESTfulリソースはデータ指向、DDDの集約はルール指向という違いがあります。この違いを理解した上で設計方針を選択する必要があります。

## 値オブジェクト
値オブジェクトは、システム固有の値（例: Money）を表現し、ドメインモデルの一部として利用します。
以下の特性を持ちます:
1. 不変性: 値オブジェクトの状態は作成後に変更されません。
2. 交換可能性: 同じ値を持つ場合、異なるインスタンスであっても等価とみなされます。
3. 等価性による比較: 値オブジェクトは等価性によって比較され、IDの概念を持ちません（エンティティとの違い）。

値オブジェクトは value_object ディレクトリに配置します。

## ファイルと責務
### {domainName}.go
このファイルでは、ドメインモデルにおけるエンティティを定義します。エンティティはライフサイクルを持ちidentityにより識別されます。またエンティティには以下の要素が含まれます:

1. プロパティ
    - エンティティが持つデータを定義します。原則として直接公開せず、外部からアクセスする場合はゲッターメソッドを使用します。
    - 例: id, userID, balance など。

2. コンストラクタ関数:
    - エンティティの生成方法を定義します。ビジネスルールを考慮し、エンティティの一貫性を確保します。主に以下の2つを提供します:
    - New 関数: 新規作成時に使用される。
    - Reconstruct 関数: データベースから復元する際に使用される。(ただしNew関数で十分な場合は不要)

3. 振る舞い (メソッド):
    - エンティティが持つビジネスロジックや振る舞いを定義します。エンティティの状態を変更する操作や、データを計算・比較するロジックを含みます。
    - 例: Withdraw, Deposit, ChangeName, ComparePassword など。

### {domainName}_specification.go
このファイルでは、エンティティの生成や操作時に必要なドメイン固有のバリデーションルールやエラー定義を管理します。主な役割は次の通りです:

1. 定数の管理:
    - ドメインルールに基づくパラメータ（例: 長さの上限/下限、最大許容数など）を定数として定義します。

2. エラーの定義:
    - ドメインで発生しうる例外的な状況を表すエラーを定義します。エラーは一貫性を保つため、適切なメッセージを付与します。

3. バリデーション関数:
    - ドメイン固有のルールに基づき、値の妥当性を検証する関数を提供します。エンティティのコンストラクタやメソッドから再利用されます。

### {domainName}_service.go
このファイルは、ドメインサービスを実装します。ドメインサービスは、エンティティや値オブジェクトが単独で処理できないビジネスロジックを提供します。特に、集約間やリポジトリを利用する操作を実現する際に重要な役割を担います。メソッドの第一引数には`context.Context型`をとります。サービスのメソッドがどのようなものかをメソッド名だけでは判断しづらい場合はInterfaceにコメントを書くことで使用する側がどういった注意点があるのかを知ることができます。

主な役割は以下の通りです:

1. ビジネスルールの実装:
    - エンティティだけでは完結しない、より高レベルなビジネスロジックを実装します。
2. リポジトリ操作の統合:
    - リポジトリを利用してデータを取得・操作し、ビジネスルールに従った処理を実現します。

### {domainName}_repository.go
このファイルでは、ドメイン層からデータ永続化の詳細を隠蔽するためのリポジトリのインターフェースを定義します。リポジトリは、データベースやその他のストレージ操作を抽象化し、ドメインモデルを扱う形で統一的にデータを管理します。

## ユニットテストのルール
### {domainName}_test.go
コンストラクタ関数とメソッドをメインにテストします。

#### コンストラクタ関数のテスト
1. 正常系としてビジネスルールに基づいたエンティティが正しく作成されることをテストします。この際、ゲッター関数を使用してエンティティのプロパティの値がそれぞれ期待通りであることを確認します。ゲッター関数を使うことで値の取得を確認することにも繋がるのでゲッター関数個別のテストは不要とします。
2. バリデーションの包括的なテストを行います。各プロパティ毎に無効な値や境界値をセットして異常系のテスト（境界値の正常系のテスト）を行います。ここでバリデーションのテストを行う為、{domainName}_specification.go に定義されているバリデーション関数を個別にテストする必要はありません。
3. 型の違いにおけるテストは不要とします。引数で型が指定されているので、型に関しては常に正確と判断して構いません。
4. 並列実行の為の`t.Parallel()`を使用することを推奨します。テスト速度の向上とテストの独立性を確保します。
5. Reconstruct関数のテストでは、New関数の内容と重複しているテストはスキップしても良いとします。
6. カバレッジは可能な限りすべての分岐に対するテストを作成し、100%を目指します。ただし、必ず100%にする必要はありません。エラーハンドリングでは殆ど発生しないパターンであっても明示することが推奨される為、再現が困難な分岐が発生します。そのような発生頻度が極めて低い分岐についてはテストを省略して構いません。（スルーする理由をコメントで明示することが推奨されます）
7. 定数やエラーの扱いについて、ドメインレイヤーのテストでは、{domainName}_specification.go に定義されている定数やエラーを直接使用せず、`期待される値を明示的に記述`します。ビジネスルールは常に変化する可能性がありますが、意図せず変更された場合にテストが失敗することで検知可能です。ただし他の集約のエンティティや値オブジェクトで定義されているエラーや定数は使用するべきです。その値を管理するのは他のエンティティの責務の為、重複管理になることを防ぎます。

#### メソッドのテスト
1. メソッドがビジネスロジックに従い、正しく動作することを確認します。特に、エンティティの状態変更やエラーメッセージの検証に重点を置きます。
2. バリデーションテストはコンストラクタ関数のテストで網羅するため、メソッドのテストでは正常系と分岐による異常系のテストに集中します。

### {domainName}_service_test.go
1. 正常系・異常系を網羅的に検証します。リポジトリや外部依存をモック化し、サービス内のすべての分岐を確認します。
2. コンストラクタ関数のテストで言及した通り、定数やエラーに関しては`期待される値を明示的に記述`します。
3. モックに渡す引数は検証しません。引数のテストはその関数のテストの責務な為と、引数がロジック内で変換されたりする場合、テストコード内に関数内のロジックを記述することになる為です。
