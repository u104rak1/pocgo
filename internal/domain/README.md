# ドメインレイヤー

## 概要
ドメインレイヤーは、ドメインモデルの知識をコードとして表現したもので、ビジネスロジックの核心部分が配置されます。このレイヤーには以下のコンポーネントが含まれます:
- ドメインエンティティ
- ドメインサービス
- 永続化用のリポジトリインターフェイス

他のレイヤーはドメインレイヤーに依存可能ですが、ドメインレイヤーは他のレイヤーに依存してはいけません。使用可能なライブラリとしては以下があります。
- Goの標準ライブラリ
- Goの準標準ライブラリ
- pkgディレクトリに配置されたアプリケーション独自のユーティリティ関数

*注意
プレゼンテーションレイヤーやインフラストラクチャーレイヤーに強く関連する型や処理は、このレイヤーに含めません。
例: echo.Context 型、トランザクション、SQLエラーなど

## 集約
ドメイン内部のディレクトリを集約単位で区切ります。pocgoでは以下のリストのように集約単位で分けています。
- account
- authentication
- transaction
- user

集約の設計
- 集約の設計は、ビジネスルールや整合性に基づいて決定します。
- 場合によっては、RESTfulリソースに合わせて分けることも有効です（API設計とモデル設計の整合性を保ち、理解を容易にするため）。

*注意
RESTfulリソースはデータ指向、DDDの集約はルール指向という違いがあります。この違いを理解した上で設計方針を選択する必要があります。

## 値オブジェクト
値オブジェクトは、システム固有の値（例: Money）を表現し、ドメインモデルの一部として利用します。
以下の特性を持ちます:
1. 不変性: 値オブジェクトの状態は作成後に変更されません。
2. 交換可能性: 同じ値を持つ場合、異なるインスタンスであっても等価とみなされます。
3. 等価性による比較: 値オブジェクトは等価性によって比較され、IDの概念を持ちません（エンティティとの違い）。

値オブジェクトは value_object ディレクトリに配置します。

## ファイルと責務
### {domainName}.go
このファイルでは、ドメインモデルにおけるエンティティを定義します。エンティティはライフサイクルを持ちidentityにより識別されます。また以下の要素が含まれます:

1. プロパティ
    - エンティティが持つデータを定義します。原則として直接公開せず、外部からアクセスする場合はゲッターメソッドを使用します。
    - 例: id, userID, balance など。

2. コンストラクタ関数:
    - エンティティの生成方法を定義します。ビジネスルールを考慮し、エンティティの一貫性を確保します。主に以下の2つを提供します:
    - New 関数: 新規作成時に使用される。
    - Reconstruct 関数: データベースから復元する際に使用される。(ただしNew関数で十分な場合は不要)

3. 振る舞い (メソッド):
    - エンティティが持つビジネスロジックや振る舞いを定義します。エンティティの状態を変更する操作や、データを計算・比較するロジックを含みます。
    - 例: Withdraw, Deposit, ChangeName, ComparePassword など。

### {domainName}_specification.go
このファイルでは、エンティティの生成や操作時に必要なドメイン固有のバリデーションルールやエラー定義を管理します。主な役割は次の通りです:

1. 定数の管理:
    - ドメインルールに基づくパラメータ（例: 長さの上限/下限、最大許容数など）を定数として定義します。

2. エラーの定義:
    - ドメインで発生しうる例外的な状況を表すエラーを定義します。エラーは一貫性を保つため、適切なメッセージを付与します。

3. バリデーション関数:
    - ドメイン固有のルールに基づき、値の妥当性を検証する関数を提供します。エンティティのコンストラクタやメソッドから再利用されます。

### {domainName}_service.go
このファイルは、ドメインサービスを実装します。ドメインサービスは、エンティティや値オブジェクトが単独で処理できないビジネスロジックを提供します。特に、集約間やリポジトリを利用する操作を実現する際に重要な役割を担います。

主な役割は以下の通りです:

1. ビジネスルールの実装:
    - エンティティだけでは完結しない、より高レベルなビジネスロジックを実装します。
2. リポジトリ操作の統合:
    - リポジトリを利用してデータを取得・操作し、ビジネスルールに従った処理を実現します。

### {domainName}_repository.go
このファイルでは、ドメイン層からデータ永続化の詳細を隠蔽するためのリポジトリのインターフェースを定義します。リポジトリは、データベースやその他のストレージ操作を抽象化し、ドメインモデルを扱う形で統一的にデータを管理します。

## ドメインレイヤーのユニットテストのルール

### コンストラクタ関数のテスト
1. エンティティ生成のテスト
    - コンストラクタ関数を用いて、ビジネスルールに基づいたエンティティが正しく作成されるかをテストします。
2. バリデーションの包括的テスト
    - コンストラクタ関数のテストには、プロパティの境界値テストを含めます。この際、{domainName}_specification.go に定義されているバリデーション関数を個別にテストする必要はありません（コンストラクタテストを通じて間接的にカバーします）。
3. 正常系テスト
    - 作成されたエンティティのプロパティが期待通りであることを確認します。この際、ID() や Name() などのゲッターを使用するため、ゲッターの個別テストは不要です。
4. 異常系テスト
    - 異常系のテストでは、発生するエラーメッセージが期待通りであることを明確に確認します。
5. 並列実行の推奨
    - `t.Parallel()` を使用してテストを並列実行します。これにより、テスト速度の向上とテストの独立性を確保します。
6. Reconstruct関数のテスト
    - Reconstruct関数のテストでは、正常系については New 関数のテストと重複しない内容に限定します。
7. カバレッジ目標
    - 可能な限りすべての分岐に対するテストを作成し、カバレッジ100%を目指します。ただし、必ず100%にする必要はありません。特に、Goのエラーハンドリングの特性上、発生頻度が極めて低い分岐についてはテストを省略して構いません（スルーする理由をコメントで明示することが推奨されます）。
8. 定数やエラーの扱い
    - ドメインレイヤーのテストでは、{domainName}_specification.go に定義されている定数やエラーを直接使用せず、「期待される値」を明示的に記述します。これにより、定数やエラーが意図せず変更された場合にテストが失敗することで検知可能です。(他のレイヤーのテストでは、これらの定数やエラーを積極的に活用します。)

### メソッドのテスト
1. 分岐テストの優先
    - 境界値テストはNew関数のテストで網羅するため、メソッドのテストでは分岐に集中します。
2. 振る舞いの確認
    - メソッドがビジネスロジックに従い、正しく動作することを確認します。特に、エンティティの状態変更やエラーメッセージの検証に重点を置きます。

### ドメインサービスのテスト
1. ファイルの配置
    - {domainName}_service_test.goにテストを書きます。
2. 分岐テスト
    - 正常系・異常系を網羅的に検証します。リポジトリや外部依存をモック化し、サービス内のすべての分岐を確認します。
