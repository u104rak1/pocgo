# インテグレーションテスト

## 方針
バックエンドサーバーとDBを結合したテストを実施し、主要なデータフローが正常に動作することを確認します。このテストでは、バックエンドとDBの接続を検証し、DBの制約に関連するエラーが適切に発生するかを確認します。なお、Controllabilityが低い外部サービスについてはmockを使用することを検討します。

## ルール
- Happy Pathの検証
  - 少なくとも1つ以上のHappy Pathをテストし、バックエンドサーバーとDBを結合したEndpointのテストを実施します。Write系のAPIの場合、可能な限り最大の入力値を使用し、バリデーション・ドメインルール・DBの制約がすべて正しく通過するかを確認します。ただし、これらのエラーチェックは基本的にユニットテストで担保するため、インテグレーションテストでは補助的な位置づけとします。
  - List系APIについては、ページネーションやlimitの指定、条件設定を十分にテストし、期待通りにデータが取得できるかを確認します。
- DBに依存するエラーのテスト
  - DBに依存して発生するエラーをテストします。例えば、同じemailが登録されている場合に発生する重複エラーは、DBのデータを使用して確認が行われるため、テストが必要です。
  - バリデーションなどコードベースで発生するエラーに関してはユニットテストの責務と考え、インテグレーションテストに含める必要はありません。
- 極めて発生頻度が低いエラーの対応
  - 発生頻度が極めて低いエラーや再現が困難なケースについては、テストのコストと効果を考慮し、テストから除外します。例えば、ULIDによる一意性が確保されている場合、実運用での衝突確率が非常に低いため、このようなSad pathはテスト対象外とします。（コメントにスキップ理由を書くのがベターです。）
- 外部サービスのmock
  - 外部サービスは選定した段階でそのリスクを許容するという判断がなされる為、全面的に信頼します。よってmockは常に期待通りの結果が返ってくると想定してテストします。（だからこそ技術選定で、メンテナンス頻度が十分に高いか？サポート対応があるか？などは重要な項目となります。）

# E2Eテスト

## 方針
E2Eテストでは、フロントエンド、バックエンド、データベース、外部APIを統合したシステム全体のテストを行い、ユーザーが実際に行う操作を再現します。

## ルール
- 環境
  - PRE環境
- テストケースの選定基準
  - Happy pathに限定し、ユーザーが一般的に行う操作を中心に検証する。
  - 全機能に影響を及ぼす重要な機能（例: Signup）についてのテストケースを優先する。
  - 利用頻度の高い操作に絞り込み、ユーザーにとって重要なTop3の動作に重点を置く。

# その他

## 負荷テスト（Load Testing）

Locustなどを使用し、ピーク時の負荷で性能を測定します。システムが処理件数や時間の要件を満たし、リソースの使用率に異常がないことを確認します。特に90パーセンタイルでの応答時間が200ms以内、また10,000リクエスト/秒（RPS）など具体的な負荷指標を設定します。

### 手順
1. テスト計画の作成

    テストの目的を明確化し、負荷の種類（通常負荷・ピーク時負荷など）を定義します。
目標とするレスポンスタイム、リソース使用率（CPU、メモリなど）、最大同時ユーザー数、リクエスト/秒 (RPS) など、具体的なKPIを設定します。

2. テストシナリオの作成

    システム内でユーザーが行う典型的な操作をシナリオ化します。例えばECサイトの場合、「商品検索」「カートに追加」「購入手続き」などの操作が対象です。ユーザーの行動パターンや、シナリオ内での各操作の頻度を反映させると、現実に近い負荷を再現できます。

3. テストツールの選定と設定

    代表的なツール：Locust, Apache JMeter, Gatlingなど。ツールを選定し、事前に設定したシナリオをツールに組み込んで負荷をかけるユーザー数、RPS、リクエストの詳細などを設定します。

4. テストの実施

    ステップ型（ユーザー数を段階的に増やす）、ピーク型（短時間で急激に増やす）、持続型（同一負荷を長時間維持する）など、複数パターンでテストを実施し、システムがどのように応答するか確認します。

5. モニタリングとデータ収集

    CPU使用率、メモリ、ディスクI/O、ネットワーク帯域などのリソースメトリクスとともに、レスポンスタイムやエラーレートなどのアプリケーションメトリクスを収集します。Grafana, Prometheusなどの監視ツールを併用すると、リアルタイムでのモニタリングが容易です。

6. 結果の分析

    各メトリクスを分析し、設定したKPIを満たしているか確認します。もしパフォーマンスが悪化する場合は、ボトルネックの特定が必要です。例えば、データベースやキャッシュの最適化、ネットワークの調整など、各レイヤーの改善ポイントを検討します。

7. 報告書作成と改善策の提案

    結果を基に、システムが目標とする性能を満たしているか報告書を作成し、必要な改善策を提案します。

## セキュリティテスト（Security Testing）
サーバ基盤やネットワーク基盤の脆弱性チェックを行い、不正アクセスやデータ流出のリスクを評価します。さらに、認証・認可の正確性や、異常検知の精度も確認します。

### 手順
1. テスト計画の策定

    セキュリティテストの対象範囲を定義し、テストの種類（脆弱性スキャン、ペネトレーションテストなど）を決定します。例えば、Webアプリケーション全般のテストを行う場合は、認証機能やデータの保護、アクセス制御が含まれます。

2. 脆弱性スキャン

    OWASP ZAPやNessus, Acunetixなどの脆弱性スキャンツールを使用して、システムの既知の脆弱性（SQLインジェクション、クロスサイトスクリプティング（XSS）など）を自動スキャンします。ツールにより、発見した脆弱性の概要と対策方法が提示されるので、脆弱性の優先順位をつけます。

3. 手動テスト（ペネトレーションテスト）

    専門のセキュリティチームが、システムに対して実際の攻撃をシミュレートし、手動で脆弱性を確認します。特に、認証・認可やデータアクセス制御、権限昇格（Privilege Escalation）に関連するテストが中心です。

4. セキュリティ要件に対するチェック

    Webアプリケーションであれば、OWASP Top 10に代表される主要な脆弱性（SQLインジェクション、XSS、CSRFなど）について、すべてテストを行い、要件を満たしているか確認します。APIであれば、認証・認可の実装やデータ暗号化が行われているかも検証します。

5. コードの静的解析

    SonarQubeやCheckmarxなどのツールを使用し、コードベースに潜在する脆弱性を自動でスキャンし、改善が必要な箇所を検出します。開発段階で導入すると、問題を早期に発見できます。

6. 報告書作成と脆弱性の修正

    脆弱性の内容とその深刻度、推奨する修正方法を記載した報告書を作成します。開発チームは報告書をもとに、発見された脆弱性に対応します。必要に応じて、セキュリティテストを再実施し、修正箇所の確認を行います。

7. 継続的なセキュリティ監視

    初期のテストに加え、運用段階でも定期的に脆弱性スキャンを行い、セキュリティの状態を監視します。新しい脅威や攻撃手法に対応するため、必要に応じてテストの内容を見直します。

## ストレステスト（Stress Testing）

システムのキャパシティ上限を超える負荷をかけ、性能が低下するポイントや、システムが回復する能力を検証します。回復動作や障害通知が適切に行われるかも確認します。

## スパイクテスト（Spike Testing）

短時間で急激に高負荷をかけ、システムが一時的なピークに対応できるかをテストします。スパイク後のリカバリーや、リソースの開放が正常かどうかも確認します。

## スケーラビリティテスト（Scalability Testing）

リソースやユーザー数の増加に対するシステムのスケーラビリティを検証し、負荷分散やスケールアウトの仕組みが正常に機能するかを確認します。

## システム内性能テスト（Performance Testing）

大量データを扱う場合でも、レスポンスや処理速度が要件を満たしているかを検証します。具体的なデータボリュームでの動作確認も含みます。

## システム内異常テスト（Fault Tolerance Testing）

機器やミドルウェアの障害が発生した場合のシステム耐性を確認し、単発のトランザクション中や高負荷時の障害に対して適切なリカバリーや通知が行われるかを確認します。

## 運用テスト（Operational Testing）

システム運用や保守手順が仕様通りに実行できるか確認し、旧バージョンと同様の監視項目が正常に動作するかを検証します。

## 災害対策テスト（Disaster Recovery Testing）

災害時のバックアップやリカバリ手順が仕様通りに動作するかを検証します。システムのダウンタイムを最小限に抑えるための各フェーズを確認します。

## 互換性テスト（Compatibility Testing）

異なるOS、ブラウザ、デバイス環境においてシステムが正常に動作するかを確認します。マルチプラットフォーム対応や、異なるバージョンのブラウザ/OSでの互換性も含みます。

## アクセシビリティテスト（Accessibility Testing）

視覚、聴覚、操作制限があるユーザーも使いやすいかを検証します。Web Content Accessibility Guidelines (WCAG)の基準を満たしているか、音声読み上げやキーボード操作への対応なども含まれます。